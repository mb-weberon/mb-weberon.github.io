<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Match-O-Matic v1.3</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        :root { --primary: #0A84FF; --success: #30D158; --error: #FF453A; --bg: #000; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); color: white; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        #camera-container { position: relative; flex-grow: 1; display: flex; align-items: center; justify-content: center; background: #000; }
        video { width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
        
        #scanner-overlay {
            position: absolute;
            width: 85%; height: 140px;
            border: 2px solid var(--primary);
            border-radius: 12px;
            box-shadow: 0 0 0 2000px rgba(0,0,0,0.8);
            z-index: 5;
        }

        /* Training View / Debug Window */
        #debug-view {
            position: absolute;
            top: 10px; right: 10px;
            width: 120px; border: 1px solid #555;
            background: #000; border-radius: 4px;
            z-index: 20; text-align: center;
        }
        #proc-canvas { width: 100%; height: auto; display: block; image-rendering: pixelated; }

        .ui-panel { background: #1c1c1e; padding: 20px; text-align: center; border-top: 1px solid #333; z-index: 10; }
        #result-display { font-size: 2.5rem; font-weight: 800; margin: 5px 0; height: 3rem; color: var(--primary); transition: all 0.2s; }
        .status-label { font-size: 0.8rem; color: #8e8e93; text-transform: uppercase; letter-spacing: 1px; }
        
        .version-footer { font-size: 10px; color: #444; padding: 5px; text-align: center; background: #1c1c1e; }
        .match-active { color: var(--success) !important; transform: scale(1.1); }
        .error-active { color: var(--error) !important; }
    </style>
</head>
<body>

    <div id="debug-view">
        <canvas id="proc-canvas"></canvas>
        <div style="font-size: 8px; color: #555;">OCR PREVIEW</div>
    </div>

    <div id="camera-container">
        <video id="video" autoplay playsinline></video>
        <div id="scanner-overlay"></div>
    </div>

    <div class="ui-panel">
        <div class="status-label" id="step-info">STEP 1: SCAN LETTER</div>
        <div id="result-display">READY</div>
        <button onclick="resetApp()" style="background: #333; border: none; color: #aaa; padding: 8px 16px; border-radius: 20px; font-size: 0.7rem; font-weight: bold;">RESET SESSION</button>
    </div>

    <div class="version-footer">v1.3 - Training View & Dual-Direction Logic</div>

    <script>
        const video = document.getElementById('video');
        const resultDisplay = document.getElementById('result-display');
        const stepInfo = document.getElementById('step-info');
        const canvas = document.getElementById('proc-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        let targetID = null;
        let isProcessing = false;

        async function init() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment", width: { ideal: 1280 } } 
                });
                video.srcObject = stream;
                setInterval(autoScan, 1000); // Faster cycle for v1.3
            } catch (e) { resultDisplay.innerText = "CAMERA ERROR"; }
        }

        async function autoScan() {
            if (isProcessing) return;
            isProcessing = true;

            const scale = video.videoWidth / video.clientWidth;
            const cropW = video.videoWidth * 0.85;
            const cropH = 140 * scale;
            const cropX = (video.videoWidth - cropW) / 2;
            const cropY = (video.videoHeight / 2) - (cropH / 2);

            canvas.width = cropW;
            canvas.height = cropH;
            ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

            // Filter for screen-based light gray text
            applyAdaptiveFilter(ctx, cropW, cropH);

            // Pass 1: Standard
            let found = await runOCR(canvas);
            
            // Pass 2: Flip if needed
            if (!found) {
                const flipCanvas = document.createElement('canvas');
                flipCanvas.width = cropW; flipCanvas.height = cropH;
                const fCtx = flipCanvas.getContext('2d');
                fCtx.translate(cropW/2, cropH/2);
                fCtx.rotate(Math.PI);
                fCtx.drawImage(canvas, -cropW/2, -cropH/2);
                found = await runOCR(flipCanvas);
            }

            if (found) handleLogic(found);
            isProcessing = false;
        }

        async function runOCR(canv) {
            const { data: { text, confidence } } = await Tesseract.recognize(canv, 'eng');
            const digits = text.replace(/\D/g, '');
            // confidence > 30 is lower, but we are filtering heavily so it's safer
            return (digits.length >= 3 && confidence > 30) ? digits : null;
        }

        function applyAdaptiveFilter(context, w, h) {
            const imgData = context.getImageData(0, 0, w, h);
            const data = imgData.data;
            
            // Contrast Stretching for Screen Glow
            for (let i = 0; i < data.length; i += 4) {
                let brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                // Aggressive threshold: screens bloom, so we want to be strict
                let v = brightness < 160 ? 0 : 255; 
                data[i] = data[i+1] = data[i+2] = v;
            }
            context.putImageData(imgData, 0, 0);
        }

        function handleLogic(num) {
            if (!targetID) {
                targetID = num;
                resultDisplay.innerText = targetID;
                stepInfo.innerText = "STEP 2: SCAN ENVELOPE";
                vibrate(100);
            } else {
                if (num === targetID) {
                    resultDisplay.innerText = "MATCH!";
                    resultDisplay.className = "match-active";
                    vibrate(500);
                    // Pause for success
                    isProcessing = true; 
                    setTimeout(() => { resetApp(); isProcessing = false; }, 4000);
                } else {
                    // Temporarily show the mismatch but keep looking
                    resultDisplay.innerText = num;
                    resultDisplay.className = "error-active";
                    vibrate([50, 50]);
                }
            }
        }

        function vibrate(p) { if(navigator.vibrate) navigator.vibrate(p); }

        function resetApp() {
            targetID = null;
            resultDisplay.innerText = "READY";
            resultDisplay.className = "";
            stepInfo.innerText = "STEP 1: SCAN LETTER";
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>