<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>IMB Scanner v2.6</title>
    <style>
            /* Updated for Landscape and Single Line Visibility */
        #fadt-text { 
            font-family: 'Courier New', monospace; 
            /* Use clamp to keep font between 12px and a reasonable scale */
            font-size: clamp(12px, 3.5vh, 2.2vw); 
            color: #fff; 
            background: #000; 
            padding: 10px 5px; 
            border-radius: 6px; 
            margin-bottom: 10px; 
            letter-spacing: 1px; 
            text-align: center; 
            border: 1px solid #444; 
            white-space: nowrap; 
            overflow-x: auto;
            min-height: 1.2em;
            user-select: all;
        }

        /* Specific Landscape Fix: Reduce padding to save vertical space */
        @media (orientation: landscape) {
            #results-area {
                padding: 10px 20px;
            }
            #fadt-text {
                margin-bottom: 8px;
                font-size: 4vh; /* Scales better when the height is short */
            }
            .control-row {
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="camera-container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="static-frame"></canvas>
    </div>
    <div id="results-area">
        <div class="control-row">
            <div id="status">v2.6.1 | Tap to Capture</div>
            <button id="accept-btn" style="background:#008000; color:white; border:none; padding:10px 24px; border-radius:8px; font-weight:bold; cursor:pointer;" onclick="decodeSelection()">DECODE</button>
        </div>
        <div id="fadt-text">---</div>
        <button class="reset-btn" onclick="resetScanner()">RESET CAMERA</button>
    </div>

<script>
    // PWA Service Worker Registration
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js');
    }

    /* ... (KEEP ALL THE JAVASCRIPT FROM v2.6 HERE) ... */
    const video = document.getElementById('video');
    const staticCanvas = document.getElementById('static-frame');
    const fadtDisplay = document.getElementById('fadt-text');
    const statusText = document.getElementById('status');
    const acceptBtn = document.getElementById('accept-btn');
    
    let isFrozen = false, cleanImageBuffer = null;
    let p1 = {x:0, y:0}, p2 = {x:0, y:0}, activeHandle = null;

    async function startCamera() {
        const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1920 } } });
        video.srcObject = s;
    }

    document.getElementById('camera-container').addEventListener('pointerdown', (e) => {
        const rect = staticCanvas.getBoundingClientRect();
        const mX = e.clientX - rect.left, mY = e.clientY - rect.top;
        if (!isFrozen) { captureFrame(); return; }
        const sP1 = nativeToScreen(p1.x, p1.y), sP2 = nativeToScreen(p2.x, p2.y);
        if (Math.hypot(mX - sP1.x, mY - sP1.y) < 45) activeHandle = 1;
        else if (Math.hypot(mX - sP2.x, mY - sP2.y) < 45) activeHandle = 2;
        else { const n = screenToNative(mX, mY); p1 = {...n}; p2 = {...n}; activeHandle = 2; }
    });

    window.addEventListener('pointermove', (e) => {
        if (!activeHandle) return;
        const rect = staticCanvas.getBoundingClientRect();
        const n = screenToNative(e.clientX - rect.left, e.clientY - rect.top);
        if (activeHandle === 1) p1 = n; else p2 = n;
        drawInterface();
    });

    window.addEventListener('pointerup', () => { activeHandle = null; });

    function captureFrame() {
        staticCanvas.width = video.videoWidth; staticCanvas.height = video.videoHeight;
        const ctx = staticCanvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        cleanImageBuffer = ctx.getImageData(0, 0, staticCanvas.width, staticCanvas.height);
        staticCanvas.style.display = 'block'; isFrozen = true;
        
        autoSeedBarcode();
        drawInterface();
        decodeSelection(); // Auto-decode immediately
    }

    function autoSeedBarcode() {
        const data = cleanImageBuffer.data, W = staticCanvas.width, H = staticCanvas.height;
        // Scan a grid to find high density of dark pixels (potential barcode)
        let bestY = H / 2, maxTransitions = 0;
        for (let y = Math.floor(H*0.3); y < H*0.7; y += 20) {
            let trans = 0;
            for (let x = Math.floor(W*0.2); x < W*0.8; x += 2) {
                const idx = (y * W + x) * 4;
                const lum = (data[idx]+data[idx+1]+data[idx+2])/3;
                if (lum < 80) trans++; 
            }
            if (trans > maxTransitions) { maxTransitions = trans; bestY = y; }
        }
        // Place initial spine horizontally centered on the best Y found
        p1 = { x: W * 0.25, y: bestY };
        p2 = { x: W * 0.75, y: bestY };
        statusText.innerText = "v2.6 | Auto-Detected Spine";
    }

    function drawInterface() {
        const ctx = staticCanvas.getContext('2d');
        ctx.putImageData(cleanImageBuffer, 0, 0);
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x), dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const boxH = staticCanvas.height * 0.08;
        ctx.save(); ctx.translate(p1.x, p1.y); ctx.rotate(angle);
        ctx.shadowBlur = 5; ctx.shadowColor = "black";
        ctx.strokeStyle = "#ff0000"; ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(dist, 0); ctx.stroke();
        ctx.strokeStyle = "#00ff00"; ctx.lineWidth = 3;
        ctx.strokeRect(0, -boxH/2, dist, boxH);
        ctx.setLineDash([15, 15]);
        for (let i = 1; i < 7; i++) {
            let ly = -boxH/2 + (i * (boxH/7));
            ctx.beginPath(); ctx.moveTo(0, ly); ctx.lineTo(dist, ly); ctx.stroke();
        }
        ctx.restore();
        drawHandle(ctx, p1.x, p1.y); drawHandle(ctx, p2.x, p2.y);
    }

    function drawHandle(ctx, x, y) {
        ctx.fillStyle = "white"; ctx.strokeStyle = "red"; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    }

    function screenToNative(sx, sy) {
        const r = staticCanvas.getBoundingClientRect();
        return { x: sx * (staticCanvas.width / r.width), y: sy * (staticCanvas.height / r.height) };
    }

    function nativeToScreen(nx, ny) {
        const r = staticCanvas.getBoundingClientRect();
        return { x: nx / (staticCanvas.width / r.width), y: ny / (staticCanvas.height / r.height) };
    }

    function decodeSelection() {
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x), dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const boxH = staticCanvas.height * 0.08, stripH = boxH / 7;
        const data = cleanImageBuffer.data, W = staticCanvas.width;
        let lums = [];
        for (let i = 0; i < dist; i += 5) {
            const px = Math.floor(p1.x + Math.cos(angle) * i), py = Math.floor(p1.y + Math.sin(angle) * i);
            const idx = (py * W + px) * 4;
            if (idx >=0 && idx < data.length) lums.push((data[idx]+data[idx+1]+data[idx+2])/3);
        }
        lums.sort((a,b)=>a-b);
        const thresh = lums[Math.floor(lums.length * 0.35)] + 25;
        let bars = [], inB = false, tempS = 0;
        for (let i = 0; i < dist; i++) {
            const px = Math.floor(p1.x + Math.cos(angle) * i), py = Math.floor(p1.y + Math.sin(angle) * i);
            const idx = (py * W + px) * 4;
            if (idx < 0 || idx >= data.length) continue;
            const isInk = ((data[idx]+data[idx+1]+data[idx+2])/3) < thresh;
            if (isInk && !inB) { inB = true; tempS = i; }
            else if (!isInk && inB) { inB = false; if (i - tempS > 1) bars.push({s: tempS, e: i}); }
        }
        const fadt = bars.map(b => {
            const m = (b.s + b.e) / 2; let zns = new Array(7).fill(false);
            for (let z = 0; z < 7; z++) {
                const off = (-boxH/2 + (z * stripH)) + (stripH/2);
                const px = Math.floor(p1.x + Math.cos(angle)*m - Math.sin(angle)*off);
                const py = Math.floor(p1.y + Math.sin(angle)*m + Math.cos(angle)*off);
                const idx = (py * W + px) * 4;
                if (idx >=0 && idx < data.length && (data[idx]+data[idx+1]+data[idx+2])/3 < thresh) zns[z] = true;
            }
            return (zns[0]||zns[1])&&(zns[5]||zns[6])?'F':(zns[0]||zns[1])?'A':(zns[5]||zns[6])?'D':'T';
        }).join('');
        fadtDisplay.innerText = fadt || "No bars detected";
        statusText.innerText = `v2.6 | ${fadt.length} Bars`;
        statusText.style.color = fadt.length === 65 ? "#00ff00" : "#ff4444";
    }

    function resetScanner() {
        staticCanvas.style.display = 'none'; isFrozen = false;
        fadtDisplay.innerText = "---"; statusText.innerText = "v2.6 | Tap to Capture"; statusText.style.color = "var(--accent)";
    }
    window.addEventListener('load', startCamera);
</script>
</body>
</html>

<script>
