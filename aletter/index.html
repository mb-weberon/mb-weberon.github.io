<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Match-O-Matic v1.11</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        :root { --primary: #0A84FF; --success: #30D158; --error: #FF453A; --bg: #000; }
        
        * { box-sizing: border-box; }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: var(--bg); color: white; font-family: -apple-system, sans-serif;
            overflow: hidden; 
        }

        #version-tag {
            position: fixed; top: 10px; left: 10px;
            background: rgba(0,0,0,0.8); padding: 4px 8px;
            border-radius: 4px; font-size: 10px; font-weight: bold;
            color: var(--primary); z-index: 100; border: 1px solid #333;
        }

        #camera-wrapper {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center; z-index: 1;
        }
        video { width: 100%; height: 100%; object-fit: cover; opacity: 0.7; }

        #scanner-overlay {
            position: absolute; top: 35%; left: 50%;
            transform: translate(-50%, -50%);
            width: 80%; height: 120px;
            border: 2px solid var(--primary); border-radius: 12px;
            box-shadow: 0 0 0 2000px rgba(0,0,0,0.8);
            z-index: 5; pointer-events: none;
        }

        #debug-view {
            position: fixed; top: 10px; right: 10px;
            width: 90px; border: 1px solid #555; background: #000; z-index: 100;
        }
        #proc-canvas { width: 100%; display: block; image-rendering: pixelated; }

        .ui-panel { 
            position: fixed; bottom: 0; left: 0; width: 100%;
            background: #1c1c1e; padding: 15px 15px calc(20px + env(safe-area-inset-bottom));
            text-align: center; z-index: 10;
            border-top: 1px solid #333;
        }

        #result-display { font-size: 2.2rem; font-weight: 900; color: var(--primary); margin: 5px 0; min-height: 2.8rem; }
        .status-label { font-size: 0.75rem; color: #8e8e93; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        
        .btn-row { display: flex; gap: 10px; justify-content: center; margin-top: 12px; }
        button { 
            background: #333; border: none; color: #fff; padding: 14px 20px; 
            border-radius: 12px; font-size: 0.85rem; cursor: pointer; font-weight: bold;
            flex: 1; max-width: 140px;
        }
        
        .match-active { color: var(--success) !important; }
        .error-active { color: var(--error) !important; }
        .hint { font-size: 10px; color: #666; margin-top: 6px; }
    </style>
</head>
<body onclick="manualScanTrigger()">

    <div id="version-tag">v1.11</div>

    <div id="debug-view">
        <canvas id="proc-canvas"></canvas>
        <div style="font-size: 7px; color: #555; text-align: center; padding: 2px;">FILTER</div>
    </div>

    <div id="camera-wrapper">
        <video id="video" autoplay playsinline></video>
        <div id="scanner-overlay"></div>
    </div>

    <div class="ui-panel">
        <div class="status-label" id="step-info">STEP 1: SCAN LETTER (+H...)</div>
        <div id="result-display">READY</div>
        <div class="hint">TAP TO SCAN â€¢ LETTER: +H123> â€¢ ENV: +123></div>
        
        <div class="btn-row">
            <button onclick="event.stopPropagation(); toggleTorch();">ðŸ”¦ LIGHT</button>
            <button onclick="event.stopPropagation(); resetApp();">RESET</button>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const resultDisplay = document.getElementById('result-display');
        const stepInfo = document.getElementById('step-info');
        const canvas = document.getElementById('proc-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        let targetID = null;
        let isProcessing = false;
        let track = null;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(freq, type, duration) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type; osc.frequency.value = freq;
            osc.connect(gain); gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
            osc.start(); gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
            osc.stop(audioCtx.currentTime + duration);
        }

        async function init() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment", width: { ideal: 1280 } } 
                });
                video.srcObject = stream;
                track = stream.getVideoTracks()[0];
                setInterval(() => { if(!isProcessing) performScan(false); }, 1500);
            } catch (e) { resultDisplay.innerText = "NO CAMERA"; }
        }

        async function toggleTorch() {
            if (!track) return;
            try {
                const settings = track.getSettings();
                await track.applyConstraints({ advanced: [{ torch: !settings.torch }] });
            } catch(e) { console.log("Torch error"); }
        }

        function manualScanTrigger() {
            if (isProcessing) return;
            playTone(800, 'sine', 0.1);
            performScan(true); 
        }

        async function performScan(isManual) {
            isProcessing = true;
            const scale = video.videoWidth / video.clientWidth;
            const cropW = video.videoWidth * 0.8;
            const cropH = 120 * scale;
            const cropX = (video.videoWidth - cropW) / 2;
            const cropY = (video.videoHeight * 0.35) - (cropH / 2);

            canvas.width = cropW; canvas.height = cropH;
            ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

            applyDynamicFilter(ctx, cropW, cropH, isManual);

            let result = await extractPattern(canvas);
            
            if (!result) {
                const fCanv = document.createElement('canvas');
                fCanv.width = cropW; fCanv.height = cropH;
                const fCtx = fCanv.getContext('2d');
                fCtx.translate(cropW/2, cropH/2); fCtx.rotate(Math.PI);
                fCtx.drawImage(canvas, -cropW/2, -cropH/2);
                result = await extractPattern(fCanv);
            }

            if (result) handleLogic(result);
            isProcessing = false;
        }

        async function extractPattern(canv) {
            const { data: { text } } = await Tesseract.recognize(canv, 'eng');
            const clean = text.replace(/\s/g, '').toUpperCase();
            
            // Step 1 Letter: +H (digits) >
            // Step 2 Envelope: + (digits) >
            const letterPattern = /\+H([0-9]+)[\>\]\)]/;
            const envelopePattern = /\+([0-9]+)[\>\]\)]/;

            if (!targetID) {
                const match = clean.match(letterPattern);
                return match ? { id: match[1], type: 'LETTER' } : null;
            } else {
                // We check envelopePattern, but MUST ensure it's not accidentally matching a +H
                const match = clean.match(envelopePattern);
                if (match && !clean.includes('+H')) {
                    return { id: match[1], type: 'ENVELOPE' };
                }
                return null;
            }
        }

        function applyDynamicFilter(context, w, h, isManual) {
            const imgData = context.getImageData(0, 0, w, h);
            const data = imgData.data;
            let total = 0;
            for (let i = 0; i < data.length; i += 4) total += (data[i] + data[i+1] + data[i+2]) / 3;
            let avg = total / (data.length / 4);
            let threshold = avg * (isManual ? 0.90 : 0.84); 
            for (let i = 0; i < data.length; i += 4) {
                let v = ((data[i] + data[i+1] + data[i+2]) / 3) < threshold ? 0 : 255;
                data[i] = data[i+1] = data[i+2] = v;
            }
            context.putImageData(imgData, 0, 0);
        }

        function handleLogic(obj) {
            if (obj.type === 'LETTER' && !targetID) {
                targetID = obj.id;
                resultDisplay.innerText = "+H" + targetID + ">";
                stepInfo.innerText = "STEP 2: SCAN ENVELOPE (+...>)";
                playTone(440, 'sine', 0.2);
            } else if (obj.type === 'ENVELOPE' && targetID) {
                if (obj.id === targetID) {
                    resultDisplay.innerText = "MATCH!";
                    resultDisplay.className = "match-active";
                    playTone(880, 'sine', 0.5);
                    isProcessing = true; 
                    setTimeout(() => { resetApp(); isProcessing = false; }, 3500);
                } else {
                    resultDisplay.innerText = "+" + obj.id + ">";
                    resultDisplay.className = "error-active";
                    playTone(200, 'sawtooth', 0.3);
                }
            }
        }

        function resetApp() {
            targetID = null;
            resultDisplay.innerText = "READY";
            resultDisplay.className = "";
            stepInfo.innerText = "STEP 1: SCAN LETTER (+H...)";
        }
        window.addEventListener('load', init);
    </script>
</body>
</html>