<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organizational Fingerprint Generator (Multi-Domain)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .info-box {
            background-color: #f9fafb; /* Tailwind gray-50 */
            border-left: 4px solid #3b82f6; /* Tailwind blue-500 */
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.375rem; /* rounded-md */
        }
        .info-box p {
            margin-bottom: 0.5rem;
        }
        .code-block {
            background-color: #1f2937; /* Tailwind gray-800 */
            color: #d1d5db; /* Tailwind gray-300 */
            padding: 1rem;
            border-radius: 0.375rem; /* rounded-md */
            overflow-x: auto;
            font-family: monospace;
        }
        .conceptual-code {
            background-color: #374151; /* Tailwind gray-700 */
            color: #9ca3af; /* Tailwind gray-400 */
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen flex flex-col items-center justify-center p-4 sm:p-6">

    <div class="bg-white shadow-xl rounded-lg p-6 md:p-8 w-full max-w-2xl">
        <header class="mb-6 text-center">
            <h1 class="text-2xl sm:text-3xl font-bold text-blue-600">Organizational Browser Fingerprint Generator</h1>
            <p class="text-gray-600 mt-2">Demonstrating client-side fingerprint generation for identifying users across an organization's multiple domains.</p>
        </header>

        <div class="info-box">
            <p class="font-semibold text-blue-700">How it Works for an Organization:</p>
            <p>This script collects browser/device attributes, combines them, and hashes them (SHA-256) to produce a fingerprint.
            When an organization runs applications or services on multiple domains (e.g., <code>service.mycompany.com</code>, <code>shop.mycompany.net</code>, <code>support.mycompany.org</code>),
            this fingerprint can be sent to a <strong>central server controlled by the organization</strong>. This allows the organization to recognize the same browser across its different domains, facilitating a unified user experience (like SSO) or consistent internal analytics, without relying on traditional cookies for this specific purpose.</p>
        </div>

        <div class="mb-6">
            <button id="generateFingerprintBtn"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                Generate Fingerprint (Client-Side)
            </button>
        </div>

        <div class="mb-6">
            <h2 class="text-xl font-semibold mb-2 text-gray-700">Collected Attributes (Client-Side):</h2>
            <div id="attributesArea" class="bg-gray-50 p-4 rounded-md border border-gray-200 text-sm text-gray-600 min-h-[100px] overflow-auto break-words">
                Click the button to see collected attributes.
            </div>
        </div>

        <div>
            <h2 class="text-xl font-semibold mb-2 text-gray-700">Generated Fingerprint (SHA-256 Hash):</h2>
            <div id="fingerprintArea" class="code-block text-sm min-h-[50px] break-all">
                Click the button to generate the fingerprint.
            </div>
            <div class="mt-2 text-sm text-gray-600">
                <p><strong>Conceptual Next Step:</strong> This fingerprint would then be sent to your organization's central server.</p>
                <pre class="conceptual-code">
// Example: Sending to an organizational endpoint
// const ORG_CENTRAL_ENDPOINT = 'https://api.your-org-domain.com/fingerprint';
// async function sendFingerprintToServer(fp) {
//   try {
//     const response = await fetch(ORG_CENTRAL_ENDPOINT, {
//       method: 'POST',
//       headers: { 'Content-Type': 'application/json' },
//       body: JSON.stringify({
//         fingerprint: fp,
//         visitedDomain: window.location.hostname,
//         timestamp: new Date().toISOString()
//       })
//     });
//     if (response.ok) {
//       const result = await response.json();
//       console.log('Fingerprint processed by org server:', result);
//       // Server might return a session ID or user status
//     } else {
//       console.error('Org server error:', response.status);
//     }
//   } catch (error) {
//     console.error('Error sending fingerprint:', error);
//   }
// }
// if (generatedFingerprint) sendFingerprintToServer(generatedFingerprint);</pre>
            </div>
        </div>

        <footer class="mt-8 pt-6 border-t border-gray-200">
            <h3 class="text-lg font-semibold text-gray-700 mb-2">Considerations for Organizational Use</h3>
            <div class="text-sm text-gray-600 space-y-2">
                <p><strong class="text-gray-800">Purpose:</strong> Intended for an organization to identify browsers across its *own* domains for unified services, internal analytics, or security. This is distinct from third-party tracking for advertising by unrelated entities.</p>
                <p><strong class="text-gray-800">Central Server:</strong> The generated fingerprint must be sent to a server endpoint owned and managed by your organization. This server would handle storing, matching, and associating fingerprints with users within your ecosystem.</p>
                <p><strong class="text-gray-800">Transparency:</strong> Clearly inform users in your privacy policy that you collect and use this type of identifier across your organization's domains and explain why (e.g., to provide seamless login, personalized services across your platforms).</p>
                <p><strong class="text-gray-800">Data Governance:</strong> Ensure strong data governance. The collected data should be used only for the stated internal purposes and not be sold or shared with unrelated third parties unless explicitly consented to by the user for such purposes.</p>
                <p><strong class="text-gray-800">Security:</strong> Secure the endpoint receiving the fingerprints and the database storing them, as this data can be sensitive.</p>
                <p><strong class="text-gray-800">Stability & Uniqueness:</strong> Fingerprint stability can vary. Browser updates or configuration changes can alter it. It's a probabilistic identifier, not an absolute one.</p>
                <p><strong class="text-gray-800">Browser Measures:</strong> Even for same-organization use, browsers' general anti-fingerprinting techniques or privacy settings might affect the consistency or availability of certain attributes. Browsers primarily distinguish sites by domain names, so cross-domain activities can face scrutiny.</p>
            </div>
        </footer>
    </div>

    <script>
        // --- Fingerprint Generation Logic ---

        const generateFingerprintBtn = document.getElementById('generateFingerprintBtn');
        const fingerprintArea = document.getElementById('fingerprintArea');
        const attributesArea = document.getElementById('attributesArea');

        // Placeholder for your organization's central fingerprint processing endpoint
        const ORGANIZATION_FP_ENDPOINT = 'https://your-organization-central-server.com/api/fingerprint'; // EXAMPLE_ONLY

        /**
         * Parses the user agent string to extract browser name, version, and OS.
         * @param {string} ua - The user agent string.
         * @returns {{browserName: string, browserVersion: string, os: string}}
         */
        function parseUserAgent(ua) {
            let browserName = 'Unknown';
            let browserVersion = 'Unknown';
            let os = 'Unknown';

            // Detect OS
            if (ua.includes('Windows NT')) os = 'Windows';
            else if (ua.includes('Mac OS X')) os = 'macOS';
            else if (ua.includes('Android')) os = 'Android';
            else if (ua.includes('iOS') || ua.includes('iPhone') || ua.includes('iPad')) os = 'iOS';
            else if (ua.includes('Linux')) os = 'Linux';

            // Detect Browser
            let match;
            if ((match = ua.match(/(Edg|Edge)\/([\d.]+)/i))) { browserName = 'Edge'; browserVersion = match[2].split('.')[0];}
            else if ((match = ua.match(/Firefox\/([\d.]+)/i))) { browserName = 'Firefox'; browserVersion = match[1].split('.')[0];}
            else if ((match = ua.match(/Chrome\/([\d.]+)/i)) && !ua.includes("Chromium")) { browserName = 'Chrome'; browserVersion = match[1].split('.')[0];}
            else if ((match = ua.match(/Safari\/([\d.]+)/i)) && !ua.includes("Chrome") && !ua.includes("Chromium")) { browserName = 'Safari'; if ((match = ua.match(/Version\/([\d.]+)/i))) { browserVersion = match[1].split('.')[0]; }}
            else if ((match = ua.match(/OPR\/([\d.]+)/i)) || (match = ua.match(/Opera\/([\d.]+)/i))) { browserName = 'Opera'; browserVersion = match[1].split('.')[0];}
            return { browserName, browserVersion, os };
        }

        /**
         * Generates a canvas fingerprint by drawing text and shapes and converting to a data URL.
         * @returns {Promise<string>} A promise that resolves with the canvas data URL or an error string.
         */
        function getCanvasFingerprint() {
            return new Promise((resolve) => {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 200; canvas.height = 50;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) { resolve('canvas-unsupported'); return; }
                    ctx.textBaseline = 'top'; ctx.font = '14px "Arial"';
                    ctx.fillStyle = '#f60'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#069'; ctx.fillText('BrowserFingerprint.js <canvas> 1.0', 2, 2);
                    resolve(canvas.toDataURL('image/png'));
                } catch (e) {
                    console.error("Canvas fingerprinting error:", e);
                    resolve('canvas-error');
                }
            });
        }

        /**
         * Collects various browser and device attributes for fingerprinting.
         * @returns {Promise<string>} A promise that resolves with a concatenated string of attributes.
         */
        async function collectAttributes() {
            const attributes = {};
            const collectedStrings = [];
            let attributesDisplay = '';
            const ua = navigator.userAgent || 'N/A';
            const { browserName, browserVersion, os } = parseUserAgent(ua);

            // User Agent and OS
            collectedStrings.push(`ua_browser:${browserName} ${browserVersion}`);
            collectedStrings.push(`ua_os:${os}`);
            attributesDisplay += `<p><strong>Browser:</strong> ${browserName} ${browserVersion}</p><p><strong>OS:</strong> ${os}</p>`;

            // Screen Resolution
            try {
                const screenResolution = `${window.screen.width || 0}x${window.screen.height || 0}`;
                collectedStrings.push(`screen:${screenResolution}`);
                attributesDisplay += `<p><strong>Screen:</strong> ${screenResolution}</p>`;
            } catch (e) {
                collectedStrings.push('screen:N/A');
                attributesDisplay += `<p><strong>Screen:</strong> N/A</p>`;
            }

            // Timezone
            try {
                const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'N/A';
                collectedStrings.push(`timezone:${timezone}`);
                attributesDisplay += `<p><strong>Timezone:</strong> ${timezone}</p>`;
            } catch (e) {
                collectedStrings.push('timezone:N/A');
                attributesDisplay += `<p><strong>Timezone:</strong> N/A</p>`;
            }

            // Language
            const language = navigator.language || (navigator.languages && navigator.languages[0]) || 'N/A';
            collectedStrings.push(`lang:${language}`);
            attributesDisplay += `<p><strong>Language:</strong> ${language}</p>`;

            // Hardware Concurrency (CPU Cores)
            const hardwareConcurrency = navigator.hardwareConcurrency || 'N/A';
            collectedStrings.push(`cores:${hardwareConcurrency}`);
            attributesDisplay += `<p><strong>Cores:</strong> ${hardwareConcurrency}</p>`;

            // Device Memory (approx GB)
            if (navigator.deviceMemory) {
                collectedStrings.push(`memory:${navigator.deviceMemory}`);
                attributesDisplay += `<p><strong>Memory (GB approx):</strong> ${navigator.deviceMemory}</p>`;
            } else {
                collectedStrings.push('memory:N/A');
                attributesDisplay += `<p><strong>Memory (GB approx):</strong> N/A</p>`;
            }

            // Canvas Fingerprint
            const canvasFingerprint = await getCanvasFingerprint();
            collectedStrings.push(`canvas_fp_val:${canvasFingerprint}`);
            attributesDisplay += `<p><strong>Canvas Data URL (full):</strong> <span style="font-size: 0.75em; word-break: break-all;">${canvasFingerprint}</span></p>`;


            attributesArea.innerHTML = attributesDisplay;
            collectedStrings.sort(); // Sort attributes for consistent hashing
            return collectedStrings.join('||');
        }

        /**
         * Computes the SHA-256 hash of a given string.
         * Robustly checks for crypto.subtle availability.
         * @param {string} str - The input string to hash.
         * @returns {Promise<string>} A promise that resolves with the SHA-256 hash in hexadecimal format or a fallback string if the Web Cryptography API is unavailable.
         */
        async function sha256(str) {
            if (!window.crypto || !window.crypto.subtle) {
                console.warn("Web Cryptography API (crypto.subtle) not available. Returning a placeholder hash.");
                // Return a consistent placeholder if crypto.subtle is not available.
                // This ensures the script doesn't crash, but the fingerprint will be generic.
                return "web-crypto-api-not-available-fallback-hash";
            }
            try {
                const buffer = new TextEncoder().encode(str);
                const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (e) {
                console.error("Error during SHA-256 hashing:", e);
                // Return a different specific error string if hashing fails, even if crypto.subtle is present.
                return "hash-operation-failed-error";
            }
        }

        // Event listener for the Generate Fingerprint button
        generateFingerprintBtn.addEventListener('click', async () => {
            fingerprintArea.textContent = 'Generating...';
            attributesArea.innerHTML = 'Collecting attributes...';
            try {
                const attributeString = await collectAttributes();
                if (attributeString) {
                    const fingerprint = await sha256(attributeString);
                    fingerprintArea.textContent = fingerprint;
                    // --- CONCEPTUAL: Send to Organization's Server ---
                    // This is where you would call a function to send 'fingerprint'
                    // to your organization's central server, e.g., using fetch.
                    // Example: sendFingerprintToMyOrgServer(fingerprint, ORGANIZATION_FP_ENDPOINT);
                    // See conceptual 'sendFingerprintToServer' function in HTML comments above.
                    console.log("Generated fingerprint:", fingerprint);
                    console.log("Conceptual endpoint:", ORGANIZATION_FP_ENDPOINT);
                } else {
                    fingerprintArea.textContent = 'Error collecting attributes.';
                    attributesArea.innerHTML = 'Could not collect attributes.';
                }
            } catch (error) {
                console.error('Error generating fingerprint:', error);
                fingerprintArea.textContent = 'Error generating fingerprint.';
                attributesArea.innerHTML = `Error: ${error.message}`;
            }
        });

        // Example function (conceptual, not called directly by button in this demo)
        // async function sendFingerprintToMyOrgServer(fp, endpointUrl) {
        //   console.log(`Conceptual send of ${fp} to ${endpointUrl}`);
        //   // try {
        //   //   const response = await fetch(endpointUrl, {
        //   //     method: 'POST',
        //   //     headers: { 'Content-Type': 'application/json' },
        //   //     body: JSON.stringify({
        //   //       fingerprint: fp,
        //   //       visitedDomain: window.location.hostname,
        //   //       timestamp: new Date().toISOString()
        //   //     })
        //   //   });
        //   //   if (response.ok) {
        //   //     const result = await response.json();
        //   //     console.log('Fingerprint processed by org server:', result);
        //   //   } else {
        //   //     console.error('Org server error:', response.status);
        //   //   }
        //   // } catch (error) {
        //   //   console.error('Error sending fingerprint:', error);
        //   // }
        // }
    </script>
</body>
</html>
